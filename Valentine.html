<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>My Eternal Valentine üíù | 3D Love Experience</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #000;
            color: #fff;
            overflow: hidden;
            height: 100vh;
            width: 100vw;
        }

        #container {
            position: relative;
            width: 100%;
            height: 100%;
        }

        #canvas-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }

        #ui {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 2;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            padding: 20px;
        }

        .title {
            font-size: 4.5em;
            font-weight: 900;
            text-align: center;
            margin-bottom: 20px;
            background: linear-gradient(45deg, #ff5e7d, #ff99ac, #ffd6d6, #ff99ac, #ff5e7d);
            background-size: 300% 300%;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            animation: titleGradient 8s ease infinite;
            text-shadow: 0 0 50px rgba(255, 94, 125, 0.5);
            font-family: 'Brush Script MT', cursive;
        }

        .message-container {
            max-width: 800px;
            width: 90%;
            background: rgba(0, 0, 0, 0.7);
            padding: 30px;
            border-radius: 25px;
            backdrop-filter: blur(15px);
            margin-bottom: 30px;
            border: 2px solid rgba(255, 94, 125, 0.3);
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.5);
            transform: translateY(0);
            transition: all 0.5s ease;
            pointer-events: all;
            position: relative;
            overflow: hidden;
        }

        .message-container::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 4px;
            background: linear-gradient(90deg, #ff5e7d, #ff99ac, #ffd6d6);
        }

        .message {
            font-size: 1.3em;
            line-height: 1.8;
            text-align: center;
            color: #fff;
            font-weight: 300;
            letter-spacing: 0.5px;
        }

        .message h2 {
            color: #ff99ac;
            margin-bottom: 15px;
            font-size: 1.8em;
        }

        .controls-panel {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            width: 90%;
            max-width: 900px;
            margin-bottom: 20px;
            pointer-events: all;
        }

        .control-btn {
            background: linear-gradient(135deg, #ff5e7d, #ff3b6d);
            color: white;
            border: none;
            padding: 16px 24px;
            border-radius: 15px;
            font-size: 1.1em;
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: 600;
            letter-spacing: 1px;
            text-transform: uppercase;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
            box-shadow: 0 8px 20px rgba(255, 94, 125, 0.3);
            position: relative;
            overflow: hidden;
        }

        .control-btn::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
            transition: 0.5s;
        }

        .control-btn:hover::before {
            left: 100%;
        }

        .control-btn:hover {
            transform: translateY(-5px) scale(1.05);
            box-shadow: 0 15px 30px rgba(255, 94, 125, 0.4);
        }

        .control-btn:active {
            transform: translateY(-2px) scale(1.02);
        }

        .control-btn.alt {
            background: linear-gradient(135deg, #9d4edd, #7b2cbf);
            box-shadow: 0 8px 20px rgba(157, 78, 221, 0.3);
        }

        .control-btn.alt:hover {
            box-shadow: 0 15px 30px rgba(157, 78, 221, 0.4);
        }

        .control-btn.rose {
            background: linear-gradient(135deg, #ff4081, #f50057);
            box-shadow: 0 8px 20px rgba(255, 64, 129, 0.3);
        }

        .control-btn.rose:hover {
            box-shadow: 0 15px 30px rgba(255, 64, 129, 0.4);
        }

        .stats-bar {
            display: flex;
            gap: 30px;
            margin-bottom: 20px;
            background: rgba(0, 0, 0, 0.6);
            padding: 15px 30px;
            border-radius: 15px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .stat {
            text-align: center;
            min-width: 120px;
        }

        .stat-value {
            font-size: 2.5em;
            font-weight: 800;
            color: #ff5e7d;
            text-shadow: 0 0 20px rgba(255, 94, 125, 0.5);
        }

        .stat-label {
            font-size: 0.9em;
            color: #aaa;
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        .instructions {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            text-align: center;
            font-size: 0.9em;
            color: rgba(255, 255, 255, 0.7);
            background: rgba(0, 0, 0, 0.5);
            padding: 12px 25px;
            border-radius: 50px;
            backdrop-filter: blur(5px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            pointer-events: all;
        }

        .scene-indicator {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.5);
            padding: 10px 20px;
            border-radius: 10px;
            font-size: 1.1em;
            backdrop-filter: blur(5px);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .scene-name {
            color: #ff99ac;
            font-weight: bold;
        }

        .love-meter {
            position: absolute;
            top: 20px;
            right: 20px;
            width: 200px;
            background: rgba(0, 0, 0, 0.5);
            padding: 15px;
            border-radius: 10px;
            backdrop-filter: blur(5px);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .meter-label {
            display: flex;
            justify-content: space-between;
            margin-bottom: 8px;
            font-size: 0.9em;
            color: #aaa;
        }

        .meter-bar {
            height: 20px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            overflow: hidden;
            position: relative;
        }

        .meter-fill {
            height: 100%;
            background: linear-gradient(90deg, #ff5e7d, #ff99ac);
            border-radius: 10px;
            width: 50%;
            transition: width 1s ease;
            position: relative;
            overflow: hidden;
        }

        .meter-fill::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(90deg, 
                transparent, 
                rgba(255, 255, 255, 0.3), 
                transparent);
            animation: shimmer 2s infinite;
        }

        @keyframes titleGradient {
            0%, 100% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
        }

        @keyframes shimmer {
            0% { transform: translateX(-100%); }
            100% { transform: translateX(100%); }
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(30px); }
            to { opacity: 1; transform: translateY(0); }
        }

        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }

        .fade-in {
            animation: fadeIn 1s ease-out forwards;
        }

        .pulse {
            animation: pulse 2s infinite ease-in-out;
        }

        .hidden {
            display: none !important;
        }

        /* Secret message modal */
        .secret-modal {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.95);
            padding: 40px;
            border-radius: 20px;
            backdrop-filter: blur(20px);
            border: 3px solid #ff5e7d;
            max-width: 600px;
            width: 90%;
            z-index: 100;
            text-align: center;
            box-shadow: 0 0 100px rgba(255, 94, 125, 0.5);
            pointer-events: all;
        }

        .secret-modal h3 {
            color: #ff99ac;
            font-size: 2.5em;
            margin-bottom: 20px;
        }

        .secret-modal p {
            font-size: 1.3em;
            line-height: 1.8;
            margin-bottom: 30px;
        }

        .close-modal {
            background: #ff5e7d;
            color: white;
            border: none;
            padding: 12px 30px;
            border-radius: 50px;
            font-size: 1.1em;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .close-modal:hover {
            background: #ff3b6d;
            transform: scale(1.05);
        }

        /* Progress ring */
        .progress-ring {
            position: absolute;
            bottom: 100px;
            right: 20px;
            width: 80px;
            height: 80px;
        }

        .progress-ring-circle {
            transform: rotate(-90deg);
            transform-origin: 50% 50%;
        }

        /* Mobile adjustments */
        @media (max-width: 768px) {
            .title {
                font-size: 2.5em;
            }
            
            .message {
                font-size: 1em;
            }
            
            .controls-panel {
                grid-template-columns: 1fr;
            }
            
            .stats-bar {
                flex-direction: column;
                gap: 10px;
                padding: 10px;
            }
            
            .stat {
                min-width: auto;
            }
            
            .love-meter, .scene-indicator {
                position: relative;
                top: auto;
                left: auto;
                right: auto;
                margin: 10px auto;
                width: 90%;
            }
        }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/effects/AsciiEffect.js"></script>
</head>
<body>
    <div id="container">
        <div id="canvas-container"></div>
        
        <div id="ui">
            <h1 class="title fade-in">My Eternal Valentine</h1>
            
            <div class="message-container fade-in" style="animation-delay: 0.2s;">
                <div class="message">
                    <h2>To My One and Only üíñ</h2>
                    <p>Every beat of my heart whispers your name. In a universe of infinite possibilities, 
                    our love is the most beautiful miracle. You are my today, my tomorrow, and all my forever.</p>
                    <p style="margin-top: 15px; font-style: italic; color: #ff99ac;">
                    "I have waited for this opportunity for more than half a century, 
                    to give you my heart and my soul."</p>
                </div>
            </div>
            
            <div class="stats-bar fade-in" style="animation-delay: 0.4s;">
                <div class="stat">
                    <div class="stat-value" id="heartCount">0</div>
                    <div class="stat-label">Hearts Collected</div>
                </div>
                <div class="stat">
                    <div class="stat-value" id="timeSpent">0:00</div>
                    <div class="stat-label">Time Together</div>
                </div>
                <div class="stat">
                    <div class="stat-value" id="loveLevel">100%</div>
                    <div class="stat-label">Love Level</div>
                </div>
            </div>
            
            <div class="controls-panel fade-in" style="animation-delay: 0.6s;">
                <button class="control-btn" id="changeScene">
                    <span>üåå</span> Change Universe
                </button>
                <button class="control-btn alt" id="addHearts">
                    <span>üíñ</span> Create Hearts
                </button>
                <button class="control-btn rose" id="toggleRose">
                    <span>üåπ</span> Magical Rose
                </button>
                <button class="control-btn" id="loveMessage">
                    <span>üíå</span> Love Note
                </button>
                <button class="control-btn alt" id="secretGarden">
                    <span>üîÆ</span> Secret Garden
                </button>
                <button class="control-btn rose" id="fireworks">
                    <span>üéÜ</span> Love Fireworks
                </button>
                <button class="control-btn" id="danceMode">
                    <span>üíÉ</span> Dance Together
                </button>
                <button class="control-btn alt" id="asciiMode">
                    <span>‚ú®</span> Digital Love
                </button>
            </div>
            
            <div class="scene-indicator fade-in" style="animation-delay: 0.8s;">
                Current Scene: <span class="scene-name" id="sceneName">Starry Night</span>
            </div>
            
            <div class="love-meter fade-in" style="animation-delay: 1s;">
                <div class="meter-label">
                    <span>Our Connection</span>
                    <span id="meterPercent">50%</span>
                </div>
                <div class="meter-bar">
                    <div class="meter-fill" id="meterFill"></div>
                </div>
            </div>
            
            <div class="instructions fade-in" style="animation-delay: 1.2s;">
                Click hearts ‚Ä¢ Drag to look around ‚Ä¢ Scroll to zoom ‚Ä¢ Explore the magic üí´
            </div>
        </div>
        
        <!-- Secret Message Modal -->
        <div class="secret-modal hidden" id="secretModal">
            <h3>My Dearest Love ‚ù§Ô∏è</h3>
            <p id="secretMessageText">
                You've discovered a secret message! This is just for you, my love.
            </p>
            <button class="close-modal" id="closeModal">Close</button>
        </div>
    </div>

    <script>
        // Main Three.js variables
        let scene, camera, renderer, controls, asciiEffect, asciiRenderer;
        let hearts = [];
        let roses = [];
        let particles = [];
        let heartCount = 0;
        let startTime = Date.now();
        let currentScene = 0;
        let isAsciiMode = false;
        let isDanceMode = false;
        let dancePartners = [];
        let meterValue = 50;
        let secretMessages = [
            "You are the reason I believe in magic.",
            "Every atom of my being is drawn to you.",
            "In your eyes, I found my home.",
            "You're the poetry my heart was waiting to write.",
            "If love were a color, it would be the shade of your smile.",
            "My soul recognized yours from the very beginning.",
            "You are my favorite notification in this noisy world.",
            "With you, every ordinary moment becomes extraordinary.",
            "I fall for you more with every heartbeat.",
            "You are the missing piece I searched for my whole life."
        ];

        // Scene configurations
        const scenes = [
            {
                name: "Starry Night",
                bgColor: 0x0a0a1a,
                fogColor: 0x0a0a1a,
                lightColor: 0xff5e7d,
                particleColor: 0xff99ac
            },
            {
                name: "Purple Dream",
                bgColor: 0x1a0033,
                fogColor: 0x1a0033,
                lightColor: 0x9d4edd,
                particleColor: 0xc77dff
            },
            {
                name: "Sunset Romance",
                bgColor: 0x33001a,
                fogColor: 0x33001a,
                lightColor: 0xff9e00,
                particleColor: 0xff6b6b
            },
            {
                name: "Ocean Love",
                bgColor: 0x001f3f,
                fogColor: 0x001f3f,
                lightColor: 0x00b4d8,
                particleColor: 0x90e0ef
            },
            {
                name: "Enchanted Forest",
                bgColor: 0x002800,
                fogColor: 0x002800,
                lightColor: 0x38b000,
                particleColor: 0x80ffdb
            }
        ];

        // Initialize the 3D scene
        function init() {
            // Create scene
            scene = new THREE.Scene();
            
            // Create camera
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 8, 20);
            
            // Create renderer
            renderer = new THREE.WebGLRenderer({ 
                antialias: true, 
                alpha: true,
                powerPreference: "high-performance"
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            
            const canvasContainer = document.getElementById('canvas-container');
            canvasContainer.appendChild(renderer.domElement);
            
            // Add orbit controls
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.minDistance = 5;
            controls.maxDistance = 100;
            controls.maxPolarAngle = Math.PI / 2;
            
            // Setup ASCII effect
            setupAsciiEffect();
            
            // Initialize scene
            changeScene(0);
            
            // Create initial environment
            createEnvironment();
            createFloatingHearts(15);
            createRoses(3);
            createParticles(100);
            
            // Handle window resize
            window.addEventListener('resize', onWindowResize);
            
            // Add click listener
            renderer.domElement.addEventListener('click', onCanvasClick, false);
            
            // Setup UI events
            setupUIEvents();
            
            // Update time counter
            setInterval(updateTimeCounter, 1000);
            
            // Start animation loop
            animate();
        }

        // Setup ASCII effect
        function setupAsciiEffect() {
            asciiEffect = new THREE.AsciiEffect(renderer);
            asciiEffect.setSize(window.innerWidth, window.innerHeight);
            asciiEffect.domElement.style.color = '#ff5e7d';
            asciiEffect.domElement.style.backgroundColor = '#000';
        }

        // Create environment
        function createEnvironment() {
            // Ground
            const groundGeometry = new THREE.CircleGeometry(50, 64);
            const groundMaterial = new THREE.MeshPhongMaterial({ 
                color: 0x1a1a2e,
                side: THREE.DoubleSide,
                shininess: 30
            });
            const ground = new THREE.Mesh(groundGeometry, groundMaterial);
            ground.rotation.x = -Math.PI / 2;
            ground.position.y = -2;
            ground.receiveShadow = true;
            scene.add(ground);
            
            // Add grid helper for visual appeal
            const gridHelper = new THREE.GridHelper(100, 50, 0xffffff, 0x333333);
            gridHelper.position.y = -1.9;
            gridHelper.material.opacity = 0.1;
            gridHelper.material.transparent = true;
            scene.add(gridHelper);
            
            // Create starfield
            createStarfield(1000);
            
            // Add floating islands
            for (let i = 0; i < 5; i++) {
                createFloatingIsland(i);
            }
        }

        // Create floating hearts
        function createFloatingHearts(count) {
            const heartGeometry = createHeartGeometry();
            
            for (let i = 0; i < count; i++) {
                const color = new THREE.Color().setHSL(Math.random(), 0.7, 0.7);
                const material = new THREE.MeshPhongMaterial({ 
                    color: color,
                    shininess: 100,
                    emissive: color.clone().multiplyScalar(0.2),
                    emissiveIntensity: 0.5
                });
                
                const heart = new THREE.Mesh(heartGeometry, material);
                
                // Random position in a sphere
                const radius = 15 + Math.random() * 10;
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.random() * Math.PI;
                
                heart.position.x = radius * Math.sin(phi) * Math.cos(theta);
                heart.position.y = 5 + radius * Math.cos(phi);
                heart.position.z = radius * Math.sin(phi) * Math.sin(theta);
                
                // Random scale
                const scale = Math.random() * 0.8 + 0.4;
                heart.scale.set(scale, scale, scale);
                
                // Store animation properties
                heart.userData = {
                    speed: Math.random() * 0.02 + 0.01,
                    floatSpeed: Math.random() * 0.01 + 0.005,
                    rotationSpeed: new THREE.Vector3(
                        Math.random() * 0.02 - 0.01,
                        Math.random() * 0.02 - 0.01,
                        Math.random() * 0.02 - 0.01
                    ),
                    floatAmplitude: Math.random() * 2 + 1,
                    originalY: heart.position.y,
                    collected: false,
                    pulseSpeed: Math.random() * 0.02 + 0.01,
                    originalScale: scale
                };
                
                heart.castShadow = true;
                scene.add(heart);
                hearts.push(heart);
            }
        }

        // Create heart geometry with more detail
        function createHeartGeometry() {
            const shape = new THREE.Shape();
            
            // Create more detailed heart shape
            shape.moveTo(0, 0.25);
            shape.bezierCurveTo(0.25, 0.25, 0.25, 0, 0, 0);
            shape.bezierCurveTo(-0.25, 0, -0.25, 0.25, 0, 0.25);
            
            // Add dip at top
            shape.bezierCurveTo(0, 0.5, 0.25, 0.75, 0, 1);
            shape.bezierCurveTo(-0.25, 0.75, 0, 0.5, 0, 0.25);
            
            const extrudeSettings = {
                steps: 2,
                depth: 0.3,
                bevelEnabled: true,
                bevelThickness: 0.1,
                bevelSize: 0.1,
                bevelSegments: 8
            };
            
            return new THREE.ExtrudeGeometry(shape, extrudeSettings);
        }

        // Create roses
        function createRoses(count) {
            for (let i = 0; i < count; i++) {
                createSingleRose(i);
            }
        }

        // Create single rose
        function createSingleRose(index) {
            const roseGroup = new THREE.Group();
            
            // Stem
            const stemGeometry = new THREE.CylinderGeometry(0.08, 0.12, 4, 12);
            const stemMaterial = new THREE.MeshPhongMaterial({ 
                color: 0x228B22,
                shininess: 30
            });
            const stem = new THREE.Mesh(stemGeometry, stemMaterial);
            stem.position.y = 2;
            roseGroup.add(stem);
            
            // Leaves
            for (let j = 0; j < 3; j++) {
                const leafGeometry = new THREE.SphereGeometry(0.3, 8, 8, 0, Math.PI);
                const leafMaterial = new THREE.MeshPhongMaterial({ color: 0x32CD32 });
                const leaf = new THREE.Mesh(leafGeometry, leafMaterial);
                leaf.position.set(
                    Math.sin(j * Math.PI * 2 / 3) * 0.5,
                    1 + j * 0.8,
                    Math.cos(j * Math.PI * 2 / 3) * 0.5
                );
                leaf.rotation.x = Math.PI / 2;
                leaf.scale.set(1, 0.3, 0.8);
                roseGroup.add(leaf);
            }
            
            // Rose petals (multiple layers)
            const petalColors = [0xff5e7d, 0xff4081, 0xf50057];
            
            for (let layer = 0; layer < 4; layer++) {
                const petalCount = 8 - layer * 2;
                const radius = 0.5 + layer * 0.3;
                
                for (let j = 0; j < petalCount; j++) {
                    const petalGeometry = new THREE.SphereGeometry(0.4, 12, 12, 0, Math.PI * 2, 0, Math.PI / 2);
                    const petalMaterial = new THREE.MeshPhongMaterial({ 
                        color: petalColors[layer % petalColors.length],
                        shininess: 100
                    });
                    
                    const petal = new THREE.Mesh(petalGeometry, petalMaterial);
                    const angle = (j / petalCount) * Math.PI * 2;
                    
                    petal.position.set(
                        Math.cos(angle) * radius,
                        4 + layer * 0.2,
                        Math.sin(angle) * radius
                    );
                    
                    petal.rotation.y = angle;
                    petal.rotation.x = Math.PI / 4;
                    petal.scale.set(1, 0.6, 0.8);
                    
                    roseGroup.add(petal);
                }
            }
            
            // Rose center
            const centerGeometry = new THREE.SphereGeometry(0.3, 16, 16);
            const centerMaterial = new THREE.MeshPhongMaterial({ 
                color: 0xffd700,
                emissive: 0x333300,
                emissiveIntensity: 0.5
            });
            const center = new THREE.Mesh(centerGeometry, centerMaterial);
            center.position.y = 4.8;
            roseGroup.add(center);
            
            // Position rose
            const angle = (index / roses.length) * Math.PI * 2;
            const radius = 8;
            roseGroup.position.set(
                Math.cos(angle) * radius,
                0,
                Math.sin(angle) * radius
            );
            
            // Store animation properties
            roseGroup.userData = {
                originalY: 0,
                floatSpeed: 0.005 + index * 0.001,
                rotationSpeed: 0.005,
                pulseSpeed: 0.01
            };
            
            roseGroup.castShadow = true;
            scene.add(roseGroup);
            roses.push(roseGroup);
        }

        // Create particles
        function createParticles(count) {
            const particleGeometry = new THREE.BufferGeometry();
            const positions = new Float32Array(count * 3);
            const colors = new Float32Array(count * 3);
            
            for (let i = 0; i < count * 3; i += 3) {
                positions[i] = (Math.random() - 0.5) * 100;
                positions[i + 1] = (Math.random() - 0.5) * 50;
                positions[i + 2] = (Math.random() - 0.5) * 100;
                
                const color = new THREE.Color().setHSL(Math.random(), 0.8, 0.7);
                colors[i] = color.r;
                colors[i + 1] = color.g;
                colors[i + 2] = color.b;
            }
            
            particleGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            particleGeometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            
            const particleMaterial = new THREE.PointsMaterial({
                size: 0.5,
                vertexColors: true,
                transparent: true,
                opacity: 0.8,
                blending: THREE.AdditiveBlending
            });
            
            const particleSystem = new THREE.Points(particleGeometry, particleMaterial);
            scene.add(particleSystem);
            
            particleSystem.userData = {
                speed: 0.01,
                update: function() {
                    this.rotation.y += this.speed;
                }
            };
            
            particles.push(particleSystem);
        }

        // Create starfield
        function createStarfield(count) {
            const starGeometry = new THREE.BufferGeometry();
            const starPositions = new Float32Array(count * 3);
            const starSizes = new Float32Array(count);
            
            for (let i = 0; i < count * 3; i += 3) {
                starPositions[i] = (Math.random() - 0.5) * 200;
                starPositions[i + 1] = (Math.random() - 0.5) * 200;
                starPositions[i + 2] = (Math.random() - 0.5) * 200;
                
                starSizes[i / 3] = Math.random() * 2 + 0.5;
            }
            
            starGeometry.setAttribute('position', new THREE.BufferAttribute(starPositions, 3));
            starGeometry.setAttribute('size', new THREE.BufferAttribute(starSizes, 1));
            
            const starMaterial = new THREE.PointsMaterial({
                color: 0xffffff,
                size: 0.1,
                transparent: true,
                opacity: 0.8,
                blending: THREE.AdditiveBlending
            });
            
            const stars = new THREE.Points(starGeometry, starMaterial);
            scene.add(stars);
        }

        // Create floating islands
        function createFloatingIsland(index) {
            const islandGroup = new THREE.Group();
            
            // Island base
            const baseGeometry = new THREE.SphereGeometry(3, 32, 32, 0, Math.PI * 2, 0, Math.PI / 2);
            const baseMaterial = new THREE.MeshPhongMaterial({ 
                color: 0x8B4513,
                shininess: 20
            });
            const base = new THREE.Mesh(baseGeometry, baseMaterial);
            base.scale.set(1, 0.3, 1);
            islandGroup.add(base);
            
            // Top surface
            const topGeometry = new THREE.CircleGeometry(2.8, 32);
            const topMaterial = new THREE.MeshPhongMaterial({ 
                color: 0x228B22,
                side: THREE.DoubleSide
            });
            const top = new THREE.Mesh(topGeometry, topMaterial);
            top.rotation.x = -Math.PI / 2;
            top.position.y = 0.01;
            islandGroup.add(top);
            
            // Position island
            const angle = (index / 5) * Math.PI * 2;
            const radius = 20;
            const height = 5 + index * 3;
            
            islandGroup.position.set(
                Math.cos(angle) * radius,
                height,
                Math.sin(angle) * radius
            );
            
            // Store animation properties
            islandGroup.userData = {
                originalY: height,
                floatSpeed: 0.002 + index * 0.001,
                rotationSpeed: 0.001
            };
            
            islandGroup.castShadow = true;
            scene.add(islandGroup);
        }

        // Create fireworks
        function createFireworks(count) {
            for (let i = 0; i < count; i++) {
                setTimeout(() => {
                    createSingleFirework();
                }, i * 200);
            }
        }

        // Create single firework
        function createSingleFirework() {
            const fireworkGroup = new THREE.Group();
            const color = new THREE.Color().setHSL(Math.random(), 0.8, 0.7);
            
            const particleCount = 100;
            const particleGeometry = new THREE.BufferGeometry();
            const positions = new Float32Array(particleCount * 3);
            const velocities = [];
            
            for (let i = 0; i < particleCount * 3; i += 3) {
                positions[i] = 0;
                positions[i + 1] = 0;
                positions[i + 2] = 0;
                
                velocities.push(new THREE.Vector3(
                    (Math.random() - 0.5) * 10,
                    Math.random() * 5 + 5,
                    (Math.random() - 0.5) * 10
                ));
            }
            
            particleGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            
            const particleMaterial = new THREE.PointsMaterial({
                size: 0.5,
                color: color,
                transparent: true,
                opacity: 1,
                blending: THREE.AdditiveBlending
            });
            
            const particles = new THREE.Points(particleGeometry, particleMaterial);
            fireworkGroup.add(particles);
            
            // Random position
            fireworkGroup.position.set(
                (Math.random() - 0.5) * 30,
                0,
                (Math.random() - 0.5) * 30
            );
            
            scene.add(fireworkGroup);
            
            // Animate firework
            let life = 2;
            const gravity = -9.8;
            
            const animateFirework = () => {
                life -= 0.016;
                
                if (life <= 0) {
                    scene.remove(fireworkGroup);
                    return;
                }
                
                const positions = particles.geometry.attributes.position.array;
                
                for (let i = 0; i < particleCount; i++) {
                    velocities[i].y += gravity * 0.016;
                    
                    positions[i * 3] += velocities[i].x * 0.016;
                    positions[i * 3 + 1] += velocities[i].y * 0.016;
                    positions[i * 3 + 2] += velocities[i].z * 0.016;
                }
                
                particles.geometry.attributes.position.needsUpdate = true;
                particleMaterial.opacity = life / 2;
                
                requestAnimationFrame(animateFirework);
            };
            
            animateFirework();
        }

        // Create dance partners
        function createDancePartners() {
            if (dancePartners.length > 0) {
                // Remove existing partners
                dancePartners.forEach(partner => scene.remove(partner));
                dancePartners = [];
            }
            
            // Create two dancing figures
            for (let i = 0; i < 2; i++) {
                const dancer = new THREE.Group();
                
                // Body
                const bodyGeometry = new THREE.CylinderGeometry(0.5, 0.5, 2, 8);
                const bodyMaterial = new THREE.MeshPhongMaterial({ 
                    color: i === 0 ? 0xff5e7d : 0x4cc9f0
                });
                const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
                body.position.y = 1;
                dancer.add(body);
                
                // Head
                const headGeometry = new THREE.SphereGeometry(0.6, 16, 16);
                const headMaterial = new THREE.MeshPhongMaterial({ 
                    color: i === 0 ? 0xff99ac : 0x90e0ef
                });
                const head = new THREE.Mesh(headGeometry, headMaterial);
                head.position.y = 2.5;
                dancer.add(head);
                
                // Arms
                for (let j = -1; j <= 1; j += 2) {
                    const armGeometry = new THREE.CylinderGeometry(0.1, 0.1, 1.5, 8);
                    const arm = new THREE.Mesh(armGeometry, bodyMaterial);
                    arm.position.set(j * 0.8, 1.5, 0);
                    arm.rotation.z = j * Math.PI / 4;
                    dancer.add(arm);
                }
                
                // Position dancers
                dancer.position.set(i * 3 - 1.5, 0, 0);
                
                dancer.userData = {
                    danceSpeed: 0.05 + i * 0.02,
                    armRotation: 0,
                    bounceHeight: 0.5
                };
                
                scene.add(dancer);
                dancePartners.push(dancer);
            }
        }

        // Handle canvas click
        function onCanvasClick(event) {
            if (isAsciiMode) return;
            
            // Calculate mouse position
            const mouse = new THREE.Vector2();
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
            
            // Create raycaster
            const raycaster = new THREE.Raycaster();
            raycaster.setFromCamera(mouse, camera);
            
            // Check for heart intersections
            const intersects = raycaster.intersectObjects(hearts);
            
            if (intersects.length > 0) {
                const heart = intersects[0].object;
                
                if (!heart.userData.collected) {
                    collectHeart(heart);
                }
            }
        }

        // Collect heart
        function collectHeart(heart) {
            heart.userData.collected = true;
            
            // Update heart count
            heartCount++;
            document.getElementById('heartCount').textContent = heartCount;
            
            // Update love meter
            meterValue = Math.min(100, meterValue + 5);
            updateLoveMeter();
            
            // Create collection effect
            createHeartCollectionEffect(heart.position);
            
            // Play sound
            playCollectionSound();
            
            // Check for special milestones
            checkMilestones();
        }

        // Create heart collection effect
        function createHeartCollectionEffect(position) {
            // Create particles
            const particleCount = 20;
            const particleGeometry = new THREE.BufferGeometry();
            const particlePositions = new Float32Array(particleCount * 3);
            
            for (let i = 0; i < particleCount * 3; i += 3) {
                particlePositions[i] = position.x;
                particlePositions[i + 1] = position.y;
                particlePositions[i + 2] = position.z;
            }
            
            particleGeometry.setAttribute('position', new THREE.BufferAttribute(particlePositions, 3));
            
            const particleMaterial = new THREE.PointsMaterial({
                size: 0.3,
                color: 0xff5e7d,
                transparent: true,
                opacity: 1,
                blending: THREE.AdditiveBlending
            });
            
            const particles = new THREE.Points(particleGeometry, particleMaterial);
            scene.add(particles);
            
            // Animate particles
            const velocities = [];
            for (let i = 0; i < particleCount; i++) {
                velocities.push(new THREE.Vector3(
                    (Math.random() - 0.5) * 2,
                    (Math.random() - 0.5) * 2 + 1,
                    (Math.random() - 0.5) * 2
                ));
            }
            
            let life = 1;
            const animateParticles = () => {
                life -= 0.03;
                
                if (life <= 0) {
                    scene.remove(particles);
                    return;
                }
                
                const positions = particles.geometry.attributes.position.array;
                
                for (let i = 0; i < particleCount; i++) {
                    positions[i * 3] += velocities[i].x;
                    positions[i * 3 + 1] += velocities[i].y;
                    positions[i * 3 + 2] += velocities[i].z;
                    
                    velocities[i].y -= 0.1; // Gravity
                }
                
                particles.geometry.attributes.position.needsUpdate = true;
                particleMaterial.opacity = life;
                particleMaterial.size = life * 0.5;
                
                requestAnimationFrame(animateParticles);
            };
            
            animateParticles();
            
            // Create floating text
            createFloatingText("+1 ‚ù§Ô∏è", position, 0xff5e7d);
        }

        // Create floating text
        function createFloatingText(text, position, color = 0xff5e7d) {
            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');
            canvas.width = 512;
            canvas.height = 256;
            
            // Draw text with glow effect
            context.font = 'bold 80px Arial';
            context.textAlign = 'center';
            context.textBaseline = 'middle';
            
            // Glow effect
            context.shadowColor = `#${color.toString(16)}`;
            context.shadowBlur = 20;
            context.fillStyle = `#${color.toString(16)}`;
            context.fillText(text, 256, 128);
            
            context.shadowBlur = 0;
            
            const texture = new THREE.CanvasTexture(canvas);
            const spriteMaterial = new THREE.SpriteMaterial({ 
                map: texture,
                transparent: true
            });
            const sprite = new THREE.Sprite(spriteMaterial);
            
            sprite.position.copy(position);
            sprite.scale.set(5, 2.5, 1);
            sprite.userData = { life: 1.0 };
            
            scene.add(sprite);
            
            // Animate sprite
            const animateSprite = () => {
                sprite.userData.life -= 0.02;
                sprite.position.y += 0.1;
                sprite.material.opacity = sprite.userData.life;
                
                if (sprite.userData.life <= 0) {
                    scene.remove(sprite);
                    return;
                }
                
                requestAnimationFrame(animateSprite);
            };
            
            animateSprite();
        }

        // Play collection sound
        function playCollectionSound() {
            try {
                const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                
                // Create multiple oscillators for a richer sound
                for (let i = 0; i < 3; i++) {
                    const oscillator = audioContext.createOscillator();
                    const gainNode = audioContext.createGain();
                    
                    oscillator.connect(gainNode);
                    gainNode.connect(audioContext.destination);
                    
                    oscillator.frequency.setValueAtTime(523.25 + i * 100, audioContext.currentTime);
                    oscillator.type = i === 0 ? 'sine' : 'triangle';
                    
                    gainNode.gain.setValueAtTime(0.1, audioContext.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.5);
                    
                    oscillator.start();
                    oscillator.stop(audioContext.currentTime + 0.5);
                }
            } catch (e) {
                // Audio not supported
            }
        }

        // Check for milestones
        function checkMilestones() {
            const milestones = [5, 10, 25, 50, 100];
            
            if (milestones.includes(heartCount)) {
                showMilestoneMessage(heartCount);
                
                if (heartCount === 10) {
                    createFireworks(5);
                } else if (heartCount === 25) {
                    createSecretGarden();
                } else if (heartCount === 50) {
                    createLoveVortex();
                }
            }
        }

        // Show milestone message
        function showMilestoneMessage(count) {
            const messages = {
                5: "You've collected 5 hearts! üíï",
                10: "10 hearts! Our love is growing! üåü",
                25: "25 hearts! You have half my heart! üíù",
                50: "50 hearts! You have my whole heart! ‚ù§Ô∏è",
                100: "100 hearts! Infinite love forever! üí´"
            };
            
            if (messages[count]) {
                createFloatingText(messages[count], new THREE.Vector3(0, 10, 0), 0xff99ac);
            }
        }

        // Create secret garden
        function createSecretGarden() {
            // Create special flowers
            for (let i = 0; i < 10; i++) {
                createSpecialFlower(i);
            }
            
            // Update message
            const messageContainer = document.querySelector('.message');
            messageContainer.innerHTML = `
                <h2>Secret Garden Unlocked! üå∏</h2>
                <p>You've discovered our secret garden, a special place that exists only in our hearts.</p>
                <p>Here, our love blooms eternally, with flowers that never wither and moments that never fade.</p>
            `;
            
            document.querySelector('.message-container').classList.add('pulse');
        }

        // Create special flower
        function createSpecialFlower(index) {
            const flowerGroup = new THREE.Group();
            
            // Stem
            const stemGeometry = new THREE.CylinderGeometry(0.05, 0.08, 3, 8);
            const stemMaterial = new THREE.MeshPhongMaterial({ color: 0x32CD32 });
            const stem = new THREE.Mesh(stemGeometry, stemMaterial);
            flowerGroup.add(stem);
            
            // Flower
            const petalCount = 12;
            const petalColor = new THREE.Color().setHSL(index / 10, 0.8, 0.7);
            
            for (let i = 0; i < petalCount; i++) {
                const petalGeometry = new THREE.SphereGeometry(0.3, 8, 8, 0, Math.PI * 2, 0, Math.PI / 2);
                const petalMaterial = new THREE.MeshPhongMaterial({ color: petalColor });
                const petal = new THREE.Mesh(petalGeometry, petalMaterial);
                
                const angle = (i / petalCount) * Math.PI * 2;
                petal.position.set(
                    Math.cos(angle) * 0.8,
                    1.5,
                    Math.sin(angle) * 0.8
                );
                
                petal.rotation.y = angle;
                petal.rotation.x = Math.PI / 3;
                petal.scale.set(1, 0.5, 0.8);
                
                flowerGroup.add(petal);
            }
            
            // Center
            const centerGeometry = new THREE.SphereGeometry(0.2, 16, 16);
            const centerMaterial = new THREE.MeshPhongMaterial({ color: 0xffd700 });
            const center = new THREE.Mesh(centerGeometry, centerMaterial);
            center.position.y = 1.5;
            flowerGroup.add(center);
            
            // Position
            const angle = (index / 10) * Math.PI * 2;
            const radius = 8;
            flowerGroup.position.set(
                Math.cos(angle) * radius,
                0,
                Math.sin(angle) * radius
            );
            
            // Add glow
            const glowGeometry = new THREE.SphereGeometry(1, 16, 16);
            const glowMaterial = new THREE.MeshBasicMaterial({
                color: petalColor,
                transparent: true,
                opacity: 0.3,
                side: THREE.BackSide
            });
            const glow = new THREE.Mesh(glowGeometry, glowMaterial);
            glow.position.y = 1.5;
            flowerGroup.add(glow);
            
            flowerGroup.userData = {
                rotationSpeed: 0.01,
                floatSpeed: 0.005
            };
            
            scene.add(flowerGroup);
        }

        // Create love vortex
        function createLoveVortex() {
            const vortexGroup = new THREE.Group();
            
            // Create spiral of hearts
            const heartCount = 100;
            const heartGeometry = createHeartGeometry();
            
            for (let i = 0; i < heartCount; i++) {
                const progress = i / heartCount;
                const angle = progress * Math.PI * 8;
                const radius = progress * 10;
                const height = progress * 20 - 10;
                
                const heartMaterial = new THREE.MeshPhongMaterial({ 
                    color: new THREE.Color().setHSL(progress, 0.8, 0.7),
                    transparent: true,
                    opacity: 0.8
                });
                
                const heart = new THREE.Mesh(heartGeometry, heartMaterial);
                heart.position.set(
                    Math.cos(angle) * radius,
                    height,
                    Math.sin(angle) * radius
                );
                
                heart.scale.setScalar(0.3);
                heart.rotation.y = angle;
                
                vortexGroup.add(heart);
            }
            
            vortexGroup.position.y = 5;
            scene.add(vortexGroup);
            
            vortexGroup.userData = {
                rotationSpeed: 0.02
            };
        }

        // Update love meter
        function updateLoveMeter() {
            const meterFill = document.getElementById('meterFill');
            const meterPercent = document.getElementById('meterPercent');
            
            meterFill.style.width = `${meterValue}%`;
            meterPercent.textContent = `${meterValue}%`;
            
            // Update love level
            document.getElementById('loveLevel').textContent = `${meterValue}%`;
        }

        // Update time counter
        function updateTimeCounter() {
            const elapsed = Math.floor((Date.now() - startTime) / 1000);
            const minutes = Math.floor(elapsed / 60);
            const seconds = elapsed % 60;
            
            document.getElementById('timeSpent').textContent = 
                `${minutes}:${seconds.toString().padStart(2, '0')}`;
        }

        // Change scene
        function changeScene(sceneIndex) {
            currentScene = sceneIndex;
            const sceneConfig = scenes[sceneIndex];
            
            // Update scene background
            scene.background = new THREE.Color(sceneConfig.bgColor);
            
            if (scene.fog) {
                scene.fog.color = new THREE.Color(sceneConfig.fogColor);
            }
            
            // Update scene name
            document.getElementById('sceneName').textContent = sceneConfig.name;
            
            // Update lighting
            scene.traverse((object) => {
                if (object.isPointLight || object.isDirectionalLight) {
                    if (object.isPointLight) {
                        object.color.setHex(sceneConfig.lightColor);
                    }
                }
            });
            
            // Update particle colors if needed
            if (sceneConfig.particleColor) {
                particles.forEach(particle => {
                    if (particle.material instanceof THREE.PointsMaterial) {
                        particle.material.color.setHex(sceneConfig.particleColor);
                    }
                });
            }
        }

        // Setup UI events
        function setupUIEvents() {
            document.getElementById('changeScene').addEventListener('click', () => {
                currentScene = (currentScene + 1) % scenes.length;
                changeScene(currentScene);
            });
            
            document.getElementById('addHearts').addEventListener('click', () => {
                createFloatingHearts(10);
                createFloatingText("New Hearts! üíï", new THREE.Vector3(0, 5, 0), 0xff99ac);
            });
            
            document.getElementById('toggleRose').addEventListener('click', () => {
                roses.forEach(rose => {
                    rose.visible = !rose.visible;
                    
                    // Add glow effect when toggling
                    if (rose.visible) {
                        createFloatingText("Roses Bloom! üåπ", rose.position, 0xff4081);
                    }
                });
            });
            
            document.getElementById('loveMessage').addEventListener('click', () => {
                const randomMessage = secretMessages[Math.floor(Math.random() * secretMessages.length)];
                const modal = document.getElementById('secretModal');
                const messageText = document.getElementById('secretMessageText');
                
                messageText.textContent = randomMessage;
                modal.classList.remove('hidden');
                
                // Create floating hearts around message
                createFloatingHearts(3);
            });
            
            document.getElementById('secretGarden').addEventListener('click', () => {
                createSecretGarden();
                createFloatingText("Secret Garden üå∏", new THREE.Vector3(0, 10, 0), 0x9d4edd);
            });
            
            document.getElementById('fireworks').addEventListener('click', () => {
                createFireworks(10);
                createFloatingText("Love Fireworks! üéÜ", new THREE.Vector3(0, 15, 0), 0xff9e00);
            });
            
            document.getElementById('danceMode').addEventListener('click', () => {
                isDanceMode = !isDanceMode;
                
                if (isDanceMode) {
                    createDancePartners();
                    createFloatingText("Let's Dance! üíÉ", new THREE.Vector3(0, 5, 0), 0x00b4d8);
                } else {
                    dancePartners.forEach(partner => scene.remove(partner));
                    dancePartners = [];
                }
            });
            
            document.getElementById('asciiMode').addEventListener('click', () => {
                isAsciiMode = !isAsciiMode;
                
                if (isAsciiMode) {
                    document.getElementById('canvas-container').innerHTML = '';
                    document.getElementById('canvas-container').appendChild(asciiEffect.domElement);
                    createFloatingText("Digital Love üíæ", new THREE.Vector3(0, 5, 0), 0xffffff);
                } else {
                    document.getElementById('canvas-container').innerHTML = '';
                    document.getElementById('canvas-container').appendChild(renderer.domElement);
                }
            });
            
            document.getElementById('closeModal').addEventListener('click', () => {
                document.getElementById('secretModal').classList.add('hidden');
            });
        }

        // Window resize handler
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            
            if (isAsciiMode) {
                asciiEffect.setSize(window.innerWidth, window.innerHeight);
            }
        }

        // Animation loop
        function animate() {
            requestAnimationFrame(animate);
            
            const time = Date.now() * 0.001;
            
            // Animate hearts
            hearts.forEach(heart => {
                if (heart.userData && !heart.userData.collected) {
                    // Floating animation
                    heart.position.y = heart.userData.originalY + 
                        Math.sin(time * heart.userData.floatSpeed) * 
                        heart.userData.floatAmplitude;
                    
                    // Rotation
                    heart.rotation.x += heart.userData.rotationSpeed.x;
                    heart.rotation.y += heart.userData.rotationSpeed.y;
                    heart.rotation.z += heart.userData.rotationSpeed.z;
                    
                    // Pulsing scale
                    const pulse = Math.sin(time * heart.userData.pulseSpeed) * 0.2 + 1;
                    heart.scale.setScalar(pulse * heart.userData.originalScale);
                    
                    // Color cycling
                    if (heart.material.color) {
                        const hue = (time * 0.1 + heart.userData.originalY * 0.01) % 1;
                        heart.material.color.setHSL(hue, 0.7, 0.7);
                    }
                }
            });
            
            // Animate roses
            roses.forEach(rose => {
                if (rose.userData && rose.visible) {
                    rose.position.y = rose.userData.originalY + 
                        Math.sin(time * rose.userData.floatSpeed) * 0.5;
                    rose.rotation.y += rose.userData.rotationSpeed;
                    
                    // Gentle pulsing
                    const scale = Math.sin(time * rose.userData.pulseSpeed) * 0.05 + 1;
                    rose.scale.setScalar(scale);
                }
            });
            
            // Animate particles
            particles.forEach(particle => {
                if (particle.userData.update) {
                    particle.userData.update();
                }
            });
            
            // Animate dance partners
            if (isDanceMode && dancePartners.length > 0) {
                dancePartners.forEach((dancer, index) => {
                    dancer.position.y = Math.sin(time * dancer.userData.danceSpeed) * 
                        dancer.userData.bounceHeight;
                    
                    dancer.rotation.y = time * dancer.userData.danceSpeed;
                    
                    // Animate arms
                    dancer.children.forEach(child => {
                        if (child.geometry instanceof THREE.CylinderGeometry) {
                            child.rotation.z = Math.sin(time * dancer.userData.danceSpeed * 2) * 
                                Math.PI / 4;
                        }
                    });
                });
            }
            
            // Update controls
            controls.update();
            
            // Render
            if (isAsciiMode) {
                asciiEffect.render(scene, camera);
            } else {
                renderer.render(scene, camera);
            }
        }

        // Initialize when page loads
        window.onload = init;
    </script>
</body>
</html>
