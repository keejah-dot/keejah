<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üíñ My Eternal Valentine | Ultimate 3D Experience</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #000;
            color: #fff;
            overflow: hidden;
            height: 100vh;
            width: 100vw;
            cursor: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 32 32"><path fill="%23ff5e7d" d="M16 4.6c-4.5 0-8.1 3.6-8.1 8.1 0 6 8.1 15.4 8.1 15.4s8.1-9.4 8.1-15.4c0-4.5-3.6-8.1-8.1-8.1z"/></svg>') 16 16, auto;
        }

        #container {
            position: relative;
            width: 100%;
            height: 100%;
        }

        #canvas-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }

        #ui {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 100;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            padding: 20px;
        }

        .title {
            font-size: 5em;
            font-weight: 900;
            text-align: center;
            margin-bottom: 20px;
            background: linear-gradient(45deg, #ff5e7d, #ff99ac, #ffd6d6, #ff99ac, #ff5e7d);
            background-size: 300% 300%;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            animation: titleGradient 8s ease infinite, titlePulse 3s ease-in-out infinite;
            text-shadow: 0 0 50px rgba(255, 94, 125, 0.5);
            font-family: 'Brush Script MT', cursive;
            filter: drop-shadow(0 0 20px rgba(255, 94, 125, 0.7));
        }

        .message-container {
            max-width: 800px;
            width: 90%;
            background: rgba(0, 0, 0, 0.85);
            padding: 40px;
            border-radius: 25px;
            backdrop-filter: blur(20px);
            margin-bottom: 40px;
            border: 2px solid rgba(255, 94, 125, 0.5);
            box-shadow: 
                0 20px 60px rgba(0, 0, 0, 0.8),
                0 0 0 1px rgba(255, 255, 255, 0.1) inset,
                0 0 100px rgba(255, 94, 125, 0.3);
            transform: translateY(0);
            transition: all 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            pointer-events: all;
            position: relative;
            overflow: hidden;
        }

        .message-container::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 4px;
            background: linear-gradient(90deg, #ff5e7d, #ff99ac, #ffd6d6, #ff99ac, #ff5e7d);
            background-size: 200% 100%;
            animation: shimmerLine 3s linear infinite;
        }

        .message-container::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: radial-gradient(circle at center, transparent 30%, rgba(255, 94, 125, 0.1) 100%);
            pointer-events: none;
        }

        .message {
            font-size: 1.4em;
            line-height: 1.8;
            text-align: center;
            color: #fff;
            font-weight: 300;
            letter-spacing: 0.5px;
            text-shadow: 0 2px 10px rgba(0, 0, 0, 0.5);
        }

        .message h2 {
            color: #ff99ac;
            margin-bottom: 20px;
            font-size: 2em;
            font-weight: 600;
            text-shadow: 0 0 30px rgba(255, 153, 172, 0.5);
        }

        .typing-text {
            min-height: 60px;
            border-right: 3px solid #ff5e7d;
            animation: blinkCursor 0.7s infinite;
            display: inline-block;
            padding-right: 5px;
        }

        .controls-panel {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 20px;
            width: 90%;
            max-width: 1200px;
            margin-bottom: 40px;
            pointer-events: all;
            background: rgba(0, 0, 0, 0.6);
            padding: 30px;
            border-radius: 20px;
            backdrop-filter: blur(15px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 20px 50px rgba(0, 0, 0, 0.5);
        }

        .control-btn {
            background: linear-gradient(135deg, #ff5e7d, #ff3b6d);
            color: white;
            border: none;
            padding: 20px 10px;
            border-radius: 15px;
            font-size: 1.1em;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            font-weight: 600;
            letter-spacing: 1px;
            text-transform: uppercase;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 10px;
            box-shadow: 
                0 10px 30px rgba(255, 94, 125, 0.4),
                0 0 0 1px rgba(255, 255, 255, 0.1) inset;
            position: relative;
            overflow: hidden;
            min-height: 120px;
        }

        .control-btn::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.3), transparent);
            transition: 0.5s;
        }

        .control-btn:hover::before {
            left: 100%;
        }

        .control-btn:hover {
            transform: translateY(-10px) scale(1.05);
            box-shadow: 
                0 20px 50px rgba(255, 94, 125, 0.6),
                0 0 30px rgba(255, 94, 125, 0.4);
        }

        .control-btn:active {
            transform: translateY(-5px) scale(1.02);
        }

        .control-btn span {
            font-size: 2.5em;
            filter: drop-shadow(0 0 10px currentColor);
        }

        .control-btn .btn-text {
            font-size: 0.9em;
            opacity: 0.9;
        }

        .control-btn.alt {
            background: linear-gradient(135deg, #9d4edd, #7b2cbf);
            box-shadow: 0 10px 30px rgba(157, 78, 221, 0.4);
        }

        .control-btn.alt:hover {
            box-shadow: 0 20px 50px rgba(157, 78, 221, 0.6);
        }

        .control-btn.rose {
            background: linear-gradient(135deg, #ff4081, #f50057);
            box-shadow: 0 10px 30px rgba(255, 64, 129, 0.4);
        }

        .control-btn.rose:hover {
            box-shadow: 0 20px 50px rgba(255, 64, 129, 0.6);
        }

        .control-btn.glow {
            background: linear-gradient(135deg, #00b4d8, #0077b6);
            box-shadow: 0 10px 30px rgba(0, 180, 216, 0.4);
        }

        .control-btn.glow:hover {
            box-shadow: 0 20px 50px rgba(0, 180, 216, 0.6);
        }

        .stats-bar {
            display: flex;
            gap: 40px;
            margin-bottom: 30px;
            background: rgba(0, 0, 0, 0.7);
            padding: 25px 50px;
            border-radius: 20px;
            backdrop-filter: blur(15px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 15px 40px rgba(0, 0, 0, 0.4);
        }

        .stat {
            text-align: center;
            min-width: 150px;
            position: relative;
        }

        .stat-value {
            font-size: 3.5em;
            font-weight: 800;
            color: #ff5e7d;
            text-shadow: 
                0 0 30px rgba(255, 94, 125, 0.8),
                0 0 60px rgba(255, 94, 125, 0.4);
            margin-bottom: 5px;
            font-family: 'Courier New', monospace;
        }

        .stat-label {
            font-size: 1em;
            color: #aaa;
            text-transform: uppercase;
            letter-spacing: 3px;
            font-weight: 300;
        }

        .instructions {
            position: absolute;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            text-align: center;
            font-size: 1em;
            color: rgba(255, 255, 255, 0.8);
            background: rgba(0, 0, 0, 0.7);
            padding: 15px 30px;
            border-radius: 50px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
            pointer-events: all;
        }

        .scene-indicator {
            position: absolute;
            top: 30px;
            left: 30px;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px 25px;
            border-radius: 15px;
            font-size: 1.2em;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
        }

        .scene-name {
            color: #ff99ac;
            font-weight: bold;
            text-shadow: 0 0 20px rgba(255, 153, 172, 0.5);
        }

        .love-meter {
            position: absolute;
            top: 30px;
            right: 30px;
            width: 300px;
            background: rgba(0, 0, 0, 0.7);
            padding: 20px;
            border-radius: 15px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
        }

        .meter-label {
            display: flex;
            justify-content: space-between;
            margin-bottom: 12px;
            font-size: 1em;
            color: #aaa;
            letter-spacing: 2px;
        }

        .meter-bar {
            height: 25px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            overflow: hidden;
            position: relative;
            box-shadow: 0 0 20px rgba(255, 94, 125, 0.2) inset;
        }

        .meter-fill {
            height: 100%;
            background: linear-gradient(90deg, #ff5e7d, #ff99ac, #ffd6d6);
            border-radius: 12px;
            width: 50%;
            transition: width 0.8s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            position: relative;
            overflow: hidden;
            box-shadow: 0 0 30px rgba(255, 94, 125, 0.5);
        }

        .meter-fill::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(90deg, 
                transparent, 
                rgba(255, 255, 255, 0.5), 
                transparent);
            animation: shimmer 2s infinite;
        }

        @keyframes titleGradient {
            0%, 100% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
        }

        @keyframes titlePulse {
            0%, 100% { transform: scale(1); filter: drop-shadow(0 0 20px rgba(255, 94, 125, 0.7)); }
            50% { transform: scale(1.05); filter: drop-shadow(0 0 40px rgba(255, 94, 125, 0.9)); }
        }

        @keyframes shimmer {
            0% { transform: translateX(-100%); }
            100% { transform: translateX(100%); }
        }

        @keyframes shimmerLine {
            0% { background-position: -200% 0; }
            100% { background-position: 200% 0; }
        }

        @keyframes blinkCursor {
            0%, 100% { border-color: #ff5e7d; }
            50% { border-color: transparent; }
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(40px) scale(0.9); }
            to { opacity: 1; transform: translateY(0) scale(1); }
        }

        @keyframes fadeOut {
            from { opacity: 1; transform: translateY(0) scale(1); }
            to { opacity: 0; transform: translateY(-40px) scale(0.9); }
        }

        @keyframes glowPulse {
            0%, 100% { box-shadow: 0 0 20px rgba(255, 94, 125, 0.5); }
            50% { box-shadow: 0 0 50px rgba(255, 94, 125, 0.8); }
        }

        .fade-in {
            animation: fadeIn 1s cubic-bezier(0.175, 0.885, 0.32, 1.275) forwards;
        }

        .fade-out {
            animation: fadeOut 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275) forwards;
        }

        .pulse {
            animation: glowPulse 2s infinite ease-in-out;
        }

        .hidden {
            display: none !important;
        }

        .particle-count {
            position: absolute;
            top: 30px;
            right: 350px;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px 25px;
            border-radius: 15px;
            font-size: 1.2em;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
        }

        /* Secret message modal */
        .secret-modal {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.95);
            padding: 50px;
            border-radius: 25px;
            backdrop-filter: blur(30px);
            border: 3px solid #ff5e7d;
            max-width: 700px;
            width: 90%;
            z-index: 1000;
            text-align: center;
            box-shadow: 
                0 0 200px rgba(255, 94, 125, 0.6),
                0 20px 80px rgba(0, 0, 0, 0.8);
            pointer-events: all;
        }

        .secret-modal h3 {
            color: #ff99ac;
            font-size: 3em;
            margin-bottom: 30px;
            text-shadow: 0 0 40px rgba(255, 153, 172, 0.7);
            font-family: 'Brush Script MT', cursive;
        }

        .secret-modal p {
            font-size: 1.5em;
            line-height: 1.8;
            margin-bottom: 40px;
            min-height: 100px;
            font-weight: 300;
        }

        .close-modal {
            background: linear-gradient(135deg, #ff5e7d, #ff3b6d);
            color: white;
            border: none;
            padding: 15px 40px;
            border-radius: 50px;
            font-size: 1.2em;
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: 600;
            letter-spacing: 2px;
            text-transform: uppercase;
            box-shadow: 0 10px 30px rgba(255, 94, 125, 0.4);
        }

        .close-modal:hover {
            background: linear-gradient(135deg, #ff3b6d, #ff1a54);
            transform: scale(1.05);
            box-shadow: 0 15px 40px rgba(255, 94, 125, 0.6);
        }

        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            z-index: 999;
            pointer-events: all;
            backdrop-filter: blur(10px);
        }

        /* Drag instruction */
        .drag-instruction {
            position: absolute;
            bottom: 100px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(255, 94, 125, 0.9);
            color: white;
            padding: 15px 30px;
            border-radius: 50px;
            font-size: 1.1em;
            box-shadow: 0 10px 30px rgba(255, 94, 125, 0.4);
            animation: fadeIn 0.5s ease, glowPulse 2s infinite;
            pointer-events: none;
            z-index: 101;
        }

        /* Loading screen */
        .loading-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #000;
            z-index: 10000;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            gap: 30px;
        }

        .loading-text {
            font-size: 2em;
            color: #ff5e7d;
            text-align: center;
            animation: glowPulse 2s infinite;
        }

        .loading-bar {
            width: 300px;
            height: 10px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 5px;
            overflow: hidden;
        }

        .loading-progress {
            height: 100%;
            background: linear-gradient(90deg, #ff5e7d, #ff99ac);
            width: 0%;
            transition: width 0.3s ease;
            border-radius: 5px;
        }

        /* Mobile adjustments */
        @media (max-width: 1200px) {
            .controls-panel {
                grid-template-columns: repeat(2, 1fr);
            }
        }

        @media (max-width: 768px) {
            .title {
                font-size: 2.8em;
            }
            
            .message {
                font-size: 1.1em;
            }
            
            .controls-panel {
                grid-template-columns: 1fr;
                padding: 20px;
                gap: 15px;
            }
            
            .control-btn {
                min-height: 100px;
                padding: 15px 10px;
            }
            
            .stats-bar {
                flex-direction: column;
                gap: 20px;
                padding: 20px;
            }
            
            .stat {
                min-width: auto;
            }
            
            .stat-value {
                font-size: 2.5em;
            }
            
            .love-meter, .scene-indicator, .particle-count {
                position: relative;
                top: auto;
                left: auto;
                right: auto;
                margin: 10px auto;
                width: 90%;
            }
            
            .secret-modal {
                padding: 30px;
            }
            
            .secret-modal h3 {
                font-size: 2em;
            }
            
            .secret-modal p {
                font-size: 1.2em;
            }
            
            .instructions {
                bottom: 20px;
                font-size: 0.9em;
                padding: 12px 25px;
            }
        }

        @media (max-width: 480px) {
            .title {
                font-size: 2em;
            }
            
            .control-btn span {
                font-size: 2em;
            }
            
            .control-btn .btn-text {
                font-size: 0.8em;
            }
        }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/EffectComposer.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/RenderPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/UnrealBloomPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/ShaderPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/shaders/CopyShader.js"></script>
</head>
<body>
    <!-- Loading Screen -->
    <div class="loading-screen" id="loadingScreen">
        <h1 class="loading-text">Loading Eternal Love...</h1>
        <div class="loading-bar">
            <div class="loading-progress" id="loadingProgress"></div>
        </div>
    </div>

    <div id="container">
        <div id="canvas-container"></div>
        
        <div id="ui">
            <h1 class="title fade-in">My Eternal Valentine</h1>
            
            <div class="message-container fade-in" style="animation-delay: 0.2s;">
                <div class="message">
                    <h2>To My One and Only üíñ</h2>
                    <p class="typing-text" id="typingText"></p>
                </div>
            </div>
            
            <div class="stats-bar fade-in" style="animation-delay: 0.4s;">
                <div class="stat">
                    <div class="stat-value" id="heartCount">0</div>
                    <div class="stat-label">Hearts Collected</div>
                </div>
                <div class="stat">
                    <div class="stat-value" id="timeSpent">0:00</div>
                    <div class="stat-label">Time Together</div>
                </div>
                <div class="stat">
                    <div class="stat-value" id="loveLevel">100%</div>
                    <div class="stat-label">Love Level</div>
                </div>
                <div class="stat">
                    <div class="stat-value" id="fireworksCount">0</div>
                    <div class="stat-label">Fireworks</div>
                </div>
            </div>
            
            <div class="controls-panel fade-in" style="animation-delay: 0.6s;">
                <button class="control-btn" id="changeScene">
                    <span>üåå</span>
                    <span class="btn-text">Change Universe</span>
                </button>
                <button class="control-btn alt" id="addHearts">
                    <span>üíñ</span>
                    <span class="btn-text">Create Hearts</span>
                </button>
                <button class="control-btn rose" id="toggleRose">
                    <span>üåπ</span>
                    <span class="btn-text">Magical Rose</span>
                </button>
                <button class="control-btn" id="loveMessage">
                    <span>üíå</span>
                    <span class="btn-text">Love Note</span>
                </button>
                <button class="control-btn alt" id="secretGarden">
                    <span>üîÆ</span>
                    <span class="btn-text">Secret Garden</span>
                </button>
                <button class="control-btn rose" id="fireworks">
                    <span>üéÜ</span>
                    <span class="btn-text">Fireworks</span>
                </button>
                <button class="control-btn" id="toggleBloom">
                    <span>‚ú®</span>
                    <span class="btn-text">Toggle Glow</span>
                </button>
                <button class="control-btn glow" id="skyboxMode">
                    <span>üåÖ</span>
                    <span class="btn-text">Skybox Mode</span>
                </button>
            </div>
            
            <div class="scene-indicator fade-in" style="animation-delay: 0.8s;">
                Universe: <span class="scene-name" id="sceneName">Starry Night</span>
            </div>
            
            <div class="particle-count fade-in" style="animation-delay: 0.9s;">
                Particles: <span id="particleCount">0</span>
            </div>
            
            <div class="love-meter fade-in" style="animation-delay: 1s;">
                <div class="meter-label">
                    <span>Our Connection</span>
                    <span id="meterPercent">50%</span>
                </div>
                <div class="meter-bar">
                    <div class="meter-fill" id="meterFill"></div>
                </div>
            </div>
            
            <div class="instructions fade-in" style="animation-delay: 1.2s;">
                üî• Click hearts ‚Ä¢ üéØ Drag to throw ‚Ä¢ üì± Scroll to zoom ‚Ä¢ ‚ú® Explore the magic
            </div>
            
            <!-- Drag Instruction -->
            <div class="drag-instruction hidden" id="dragInstruction">
                üéØ Click and drag to throw hearts!
            </div>
        </div>
        
        <!-- Modal Overlay -->
        <div class="modal-overlay hidden" id="modalOverlay"></div>
        
        <!-- Secret Message Modal -->
        <div class="secret-modal hidden" id="secretModal">
            <h3>My Dearest Love ‚ù§Ô∏è</h3>
            <p class="typing-text" id="secretMessageText"></p>
            <button class="close-modal" id="closeModal">Close Message</button>
        </div>
    </div>

    <script>
        // Main Three.js variables
        let scene, camera, renderer, controls, composer, bloomPass;
        let hearts = [];
        let roses = [];
        let particles = [];
        let starParticles = [];
        let heartCount = 0;
        let fireworksCount = 0;
        let startTime = Date.now();
        let currentScene = 0;
        let isBloomEnabled = true;
        let isDragging = false;
        let draggedHeart = null;
        let dragStartPosition = new THREE.Vector3();
        let dragVelocity = new THREE.Vector3();
        let mousePosition = new THREE.Vector2();
        let raycaster = new THREE.Raycaster();
        
        // Post-processing for bloom/glow effect
        let bloomParams = {
            exposure: 1,
            bloomStrength: 2.0,
            bloomThreshold: 0,
            bloomRadius: 0.8
        };

        // Scene configurations
        const scenes = [
            {
                name: "Starry Night",
                bgColor: 0x0a0a1a,
                fogColor: 0x0a0a1a,
                lightColor: 0xff5e7d,
                particleColor: 0xff99ac,
                starColor: 0xffffff,
                starCount: 5000
            },
            {
                name: "Purple Dream",
                bgColor: 0x1a0033,
                fogColor: 0x1a0033,
                lightColor: 0x9d4edd,
                particleColor: 0xc77dff,
                starColor: 0xd8b4fe,
                starCount: 4000
            },
            {
                name: "Sunset Romance",
                bgColor: 0x33001a,
                fogColor: 0x33001a,
                lightColor: 0xff9e00,
                particleColor: 0xff6b6b,
                starColor: 0xffb347,
                starCount: 3000
            },
            {
                name: "Ocean Love",
                bgColor: 0x001f3f,
                fogColor: 0x001f3f,
                lightColor: 0x00b4d8,
                particleColor: 0x90e0ef,
                starColor: 0x48cae4,
                starCount: 6000
            },
            {
                name: "Enchanted Forest",
                bgColor: 0x002800,
                fogColor: 0x002800,
                lightColor: 0x38b000,
                particleColor: 0x80ffdb,
                starColor: 0x9ef01a,
                starCount: 4500
            },
            {
                name: "Galaxy Core",
                bgColor: 0x000000,
                fogColor: 0x000000,
                lightColor: 0xff00ff,
                particleColor: 0xff00ff,
                starColor: 0xffffff,
                starCount: 10000
            }
        ];

        // Typewriter messages
        const typewriterMessages = [
            "Every beat of my heart whispers your name...",
            "In a universe of infinite possibilities, our love is the most beautiful miracle...",
            "You are my today, my tomorrow, and all my forever...",
            "I have waited for this opportunity for more than half a century...",
            "To give you my heart and my soul...",
            "With every passing moment, my love for you grows stronger...",
            "You are the missing piece I never knew I needed...",
            "In your eyes, I found my home, my peace, my everything...",
            "Our love story is my favorite adventure...",
            "Forever and always, my love..."
        ];

        const secretMessages = [
            "You are the reason I believe in magic...",
            "Every atom of my being is drawn to you...",
            "In your eyes, I found my home...",
            "You're the poetry my heart was waiting to write...",
            "If love were a color, it would be the shade of your smile...",
            "My soul recognized yours from the very beginning...",
            "You are my favorite notification in this noisy world...",
            "With you, every ordinary moment becomes extraordinary...",
            "I fall for you more with every heartbeat...",
            "You are the missing piece I searched for my whole life..."
        ];

        // Initialize the 3D scene
        function init() {
            updateLoadingProgress(10);
            
            // Create scene
            scene = new THREE.Scene();
            updateLoadingProgress(20);
            
            // Create camera
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 8, 20);
            updateLoadingProgress(30);
            
            // Create renderer with enhanced settings
            renderer = new THREE.WebGLRenderer({ 
                antialias: true,
                alpha: true,
                powerPreference: "high-performance"
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.outputEncoding = THREE.sRGBEncoding;
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 1.2;
            
            const canvasContainer = document.getElementById('canvas-container');
            canvasContainer.appendChild(renderer.domElement);
            updateLoadingProgress(40);
            
            // Add orbit controls
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.minDistance = 5;
            controls.maxDistance = 100;
            controls.maxPolarAngle = Math.PI / 2;
            updateLoadingProgress(50);
            
            // Setup post-processing for bloom effect
            setupPostProcessing();
            updateLoadingProgress(60);
            
            // Initialize scene
            changeScene(0);
            updateLoadingProgress(70);
            
            // Create initial environment
            createEnvironment();
            updateLoadingProgress(80);
            createFloatingHearts(20);
            updateLoadingProgress(85);
            createRoses(3);
            updateLoadingProgress(90);
            createParticles(100);
            updateLoadingProgress(95);
            
            // Setup event listeners
            setupEventListeners();
            
            // Start typewriter effect
            startTypewriterEffect();
            
            // Complete loading
            setTimeout(() => {
                document.getElementById('loadingScreen').classList.add('hidden');
                document.getElementById('ui').style.opacity = '1';
                updateLoadingProgress(100);
            }, 500);
            
            // Start animation loop
            animate();
        }

        // Setup post-processing for bloom/glow effect
        function setupPostProcessing() {
            composer = new THREE.EffectComposer(renderer);
            const renderPass = new THREE.RenderPass(scene, camera);
            composer.addPass(renderPass);
            
            bloomPass = new THREE.UnrealBloomPass(
                new THREE.Vector2(window.innerWidth, window.innerHeight),
                bloomParams.bloomStrength,
                bloomParams.bloomRadius,
                bloomParams.bloomThreshold
            );
            composer.addPass(bloomPass);
        }

        // Create enhanced environment
        function createEnvironment() {
            // Enhanced ground with gradient
            const groundGeometry = new THREE.CircleGeometry(80, 128);
            const groundMaterial = new THREE.MeshPhongMaterial({ 
                color: 0x1a1a2e,
                side: THREE.DoubleSide,
                shininess: 50,
                specular: 0x333333
            });
            const ground = new THREE.Mesh(groundGeometry, groundMaterial);
            ground.rotation.x = -Math.PI / 2;
            ground.position.y = -5;
            ground.receiveShadow = true;
            scene.add(ground);
            
            // Add radial gradient to ground
            const groundGradientGeometry = new THREE.CircleGeometry(100, 128);
            const groundGradientMaterial = new THREE.MeshBasicMaterial({ 
                color: 0xff5e7d,
                side: THREE.DoubleSide,
                transparent: true,
                opacity: 0.05
            });
            const groundGradient = new THREE.Mesh(groundGradientGeometry, groundGradientMaterial);
            groundGradient.rotation.x = -Math.PI / 2;
            groundGradient.position.y = -4.9;
            scene.add(groundGradient);
            
            // Enhanced lighting
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xff5e7d, 2);
            directionalLight.position.set(15, 20, 10);
            directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 2048;
            directionalLight.shadow.mapSize.height = 2048;
            directionalLight.shadow.camera.near = 0.5;
            directionalLight.shadow.camera.far = 500;
            directionalLight.shadow.camera.left = -100;
            directionalLight.shadow.camera.right = 100;
            directionalLight.shadow.camera.top = 100;
            directionalLight.shadow.camera.bottom = -100;
            scene.add(directionalLight);
            
            const pointLight = new THREE.PointLight(0xff99ac, 3, 200);
            pointLight.position.set(-10, 15, 10);
            pointLight.castShadow = true;
            scene.add(pointLight);
            
            const pointLight2 = new THREE.PointLight(0x9d4edd, 2, 200);
            pointLight2.position.set(10, 10, -10);
            scene.add(pointLight2);
            
            // Add volumetric light effect
            const volumetricGeometry = new THREE.SphereGeometry(30, 32, 32);
            const volumetricMaterial = new THREE.MeshBasicMaterial({
                color: 0xff5e7d,
                transparent: true,
                opacity: 0.03,
                side: THREE.BackSide
            });
            const volumetricSphere = new THREE.Mesh(volumetricGeometry, volumetricMaterial);
            scene.add(volumetricSphere);
            
            // Create enhanced starfield
            createStarfield(scenes[currentScene].starCount);
            
            // Update particle count display
            updateParticleCount();
        }

        // Create enhanced floating hearts with REAL heart shape
        function createFloatingHearts(count) {
            const heartGeometry = createEnhancedHeartGeometry();
            
            for (let i = 0; i < count; i++) {
                const hue = Math.random();
                const color = new THREE.Color().setHSL(hue, 0.9, 0.7);
                const material = new THREE.MeshPhysicalMaterial({ 
                    color: color,
                    roughness: 0.1,
                    metalness: 0.3,
                    clearcoat: 1.0,
                    clearcoatRoughness: 0.1,
                    emissive: color.clone().multiplyScalar(0.3),
                    emissiveIntensity: 1.0,
                    transparent: true,
                    opacity: 0.95
                });
                
                const heart = new THREE.Mesh(heartGeometry, material);
                
                // Random position in a sphere
                const radius = 20 + Math.random() * 15;
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.random() * Math.PI;
                
                heart.position.x = radius * Math.sin(phi) * Math.cos(theta);
                heart.position.y = 10 + radius * Math.cos(phi);
                heart.position.z = radius * Math.sin(phi) * Math.sin(theta);
                
                // Random scale
                const scale = Math.random() * 1.2 + 0.8;
                heart.scale.set(scale, scale, scale);
                
                // Enhanced animation properties
                heart.userData = {
                    speed: Math.random() * 0.03 + 0.02,
                    floatSpeed: Math.random() * 0.02 + 0.01,
                    rotationSpeed: new THREE.Vector3(
                        Math.random() * 0.03 - 0.015,
                        Math.random() * 0.03 - 0.015,
                        Math.random() * 0.03 - 0.015
                    ),
                    floatAmplitude: Math.random() * 3 + 2,
                    originalY: heart.position.y,
                    collected: false,
                    pulseSpeed: Math.random() * 0.03 + 0.02,
                    originalScale: scale,
                    hue: hue,
                    dragVelocity: new THREE.Vector3(),
                    isDragged: false
                };
                
                heart.castShadow = true;
                heart.receiveShadow = true;
                scene.add(heart);
                hearts.push(heart);
            }
            
            updateParticleCount();
        }

        // Create enhanced REAL 3D heart geometry
        function createEnhancedHeartGeometry() {
            const shape = new THREE.Shape();
            
            // Create detailed heart shape
            shape.moveTo(0, 0.25);
            
            // Left curve
            shape.bezierCurveTo(-0.5, 0.25, -0.5, -0.5, 0, -0.5);
            
            // Right curve
            shape.bezierCurveTo(0.5, -0.5, 0.5, 0.25, 0, 0.25);
            
            // Top curves for heart shape
            shape.bezierCurveTo(0, 0.5, 0.25, 0.75, 0, 1);
            shape.bezierCurveTo(-0.25, 0.75, 0, 0.5, 0, 0.25);
            
            const extrudeSettings = {
                steps: 3,
                depth: 0.4,
                bevelEnabled: true,
                bevelThickness: 0.1,
                bevelSize: 0.1,
                bevelSegments: 10,
                bevelOffset: 0,
                bevelType: 'round'
            };
            
            const geometry = new THREE.ExtrudeGeometry(shape, extrudeSettings);
            
            // Center the geometry
            geometry.center();
            
            // Smooth the geometry
            geometry.computeVertexNormals();
            
            return geometry;
        }

        // Create enhanced starfield with parallax
        function createStarfield(count) {
            // Clear existing stars
            starParticles.forEach(star => scene.remove(star));
            starParticles = [];
            
            const starGeometry = new THREE.BufferGeometry();
            const starPositions = new Float32Array(count * 3);
            const starSizes = new Float32Array(count);
            const starColors = new Float32Array(count * 3);
            
            const sceneConfig = scenes[currentScene];
            
            for (let i = 0; i < count * 3; i += 3) {
                // Create stars in different layers for parallax effect
                const layer = Math.floor(i / 1000) + 1;
                const distance = 100 + layer * 50;
                
                starPositions[i] = (Math.random() - 0.5) * distance * 2;
                starPositions[i + 1] = (Math.random() - 0.5) * distance * 2;
                starPositions[i + 2] = (Math.random() - 0.5) * distance * 2;
                
                starSizes[i / 3] = Math.random() * 0.3 + 0.1;
                
                // Add some colored stars
                const color = new THREE.Color(sceneConfig.starColor);
                if (Math.random() > 0.7) {
                    color.setHSL(Math.random(), 0.8, 0.8);
                }
                
                starColors[i] = color.r;
                starColors[i + 1] = color.g;
                starColors[i + 2] = color.b;
            }
            
            starGeometry.setAttribute('position', new THREE.BufferAttribute(starPositions, 3));
            starGeometry.setAttribute('size', new THREE.BufferAttribute(starSizes, 1));
            starGeometry.setAttribute('color', new THREE.BufferAttribute(starColors, 3));
            
            const starMaterial = new THREE.PointsMaterial({
                size: 0.2,
                vertexColors: true,
                transparent: true,
                opacity: 0.9,
                blending: THREE.AdditiveBlending,
                sizeAttenuation: true
            });
            
            const stars = new THREE.Points(starGeometry, starMaterial);
            stars.userData = {
                layers: Math.ceil(count / 1000),
                baseSpeed: 0.0001
            };
            scene.add(stars);
            starParticles.push(stars);
        }

        // Create enhanced particles
        function createParticles(count) {
            const particleGeometry = new THREE.BufferGeometry();
            const positions = new Float32Array(count * 3);
            const colors = new Float32Array(count * 3);
            const sizes = new Float32Array(count);
            
            const sceneConfig = scenes[currentScene];
            
            for (let i = 0; i < count * 3; i += 3) {
                positions[i] = (Math.random() - 0.5) * 150;
                positions[i + 1] = (Math.random() - 0.5) * 80 + 10;
                positions[i + 2] = (Math.random() - 0.5) * 150;
                
                const color = new THREE.Color(sceneConfig.particleColor);
                color.offsetHSL(Math.random() * 0.3 - 0.15, 0, Math.random() * 0.2 - 0.1);
                
                colors[i] = color.r;
                colors[i + 1] = color.g;
                colors[i + 2] = color.b;
                
                sizes[i / 3] = Math.random() * 0.8 + 0.2;
            }
            
            particleGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            particleGeometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            particleGeometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));
            
            const particleMaterial = new THREE.PointsMaterial({
                size: 0.6,
                vertexColors: true,
                transparent: true,
                opacity: 0.8,
                blending: THREE.AdditiveBlending,
                sizeAttenuation: true
            });
            
            const particleSystem = new THREE.Points(particleGeometry, particleMaterial);
            
            particleSystem.userData = {
                speed: 0.005,
                rotationSpeed: 0.001,
                timeOffset: Math.random() * 1000
            };
            
            scene.add(particleSystem);
            particles.push(particleSystem);
            
            updateParticleCount();
        }

        // Create enhanced fireworks
        function createFireworks(count, position = null) {
            fireworksCount += count;
            document.getElementById('fireworksCount').textContent = fireworksCount;
            
            for (let i = 0; i < count; i++) {
                setTimeout(() => {
                    createEnhancedFirework(position);
                }, i * 150);
            }
        }

        // Create single enhanced firework
        function createEnhancedFirework(position = null) {
            const fireworkGroup = new THREE.Group();
            const hue = Math.random();
            const color = new THREE.Color().setHSL(hue, 0.9, 0.7);
            
            const particleCount = 100;
            const particleGeometry = new THREE.BufferGeometry();
            const positions = new Float32Array(particleCount * 3);
            const colors = new Float32Array(particleCount * 3);
            const sizes = new Float32Array(particleCount);
            const velocities = [];
            
            for (let i = 0; i < particleCount * 3; i += 3) {
                positions[i] = 0;
                positions[i + 1] = 0;
                positions[i + 2] = 0;
                
                // Create explosion in all directions
                const velocity = new THREE.Vector3(
                    (Math.random() - 0.5) * 8,
                    (Math.random() - 0.5) * 8 + 4,
                    (Math.random() - 0.5) * 8
                );
                velocities.push(velocity);
                
                // Random color variation
                const particleColor = color.clone();
                particleColor.offsetHSL(Math.random() * 0.2 - 0.1, 0, Math.random() * 0.2 - 0.1);
                
                colors[i] = particleColor.r;
                colors[i + 1] = particleColor.g;
                colors[i + 2] = particleColor.b;
                
                sizes[i / 3] = Math.random() * 0.4 + 0.2;
            }
            
            particleGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            particleGeometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            particleGeometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));
            
            const particleMaterial = new THREE.PointsMaterial({
                size: 0.5,
                vertexColors: true,
                transparent: true,
                opacity: 1,
                blending: THREE.AdditiveBlending,
                sizeAttenuation: true
            });
            
            const particles = new THREE.Points(particleGeometry, particleMaterial);
            fireworkGroup.add(particles);
            
            // Random or specific position
            if (!position) {
                position = new THREE.Vector3(
                    (Math.random() - 0.5) * 40,
                    5 + Math.random() * 20,
                    (Math.random() - 0.5) * 40
                );
            }
            
            fireworkGroup.position.copy(position);
            scene.add(fireworkGroup);
            
            // Create light at firework position
            const fireworkLight = new THREE.PointLight(color, 3, 50);
            fireworkLight.position.copy(position);
            scene.add(fireworkLight);
            
            // Animate firework
            let life = 2.5;
            const gravity = -4;
            
            const animateFirework = () => {
                life -= 0.016;
                
                if (life <= 0) {
                    scene.remove(fireworkGroup);
                    scene.remove(fireworkLight);
                    return;
                }
                
                const positions = particles.geometry.attributes.position.array;
                
                for (let i = 0; i < particleCount; i++) {
                    velocities[i].y += gravity * 0.016;
                    
                    positions[i * 3] += velocities[i].x * 0.016;
                    positions[i * 3 + 1] += velocities[i].y * 0.016;
                    positions[i * 3 + 2] += velocities[i].z * 0.016;
                }
                
                particles.geometry.attributes.position.needsUpdate = true;
                particleMaterial.opacity = life / 2.5;
                particleMaterial.size = life * 0.3;
                
                // Fade light
                fireworkLight.intensity = life * 1.2;
                
                requestAnimationFrame(animateFirework);
            };
            
            animateFirework();
        }

        // Setup event listeners
        function setupEventListeners() {
            // Window resize
            window.addEventListener('resize', onWindowResize);
            
            // Mouse events for dragging hearts
            renderer.domElement.addEventListener('mousedown', onMouseDown, false);
            renderer.domElement.addEventListener('mousemove', onMouseMove, false);
            renderer.domElement.addEventListener('mouseup', onMouseUp, false);
            renderer.domElement.addEventListener('mouseleave', onMouseUp, false);
            
            // Touch events for mobile
            renderer.domElement.addEventListener('touchstart', onTouchStart, false);
            renderer.domElement.addEventListener('touchmove', onTouchMove, false);
            renderer.domElement.addEventListener('touchend', onTouchEnd, false);
            
            // Setup UI events
            setupUIEvents();
            
            // Update time counter
            setInterval(updateTimeCounter, 1000);
        }

        // Mouse down event for dragging hearts
        function onMouseDown(event) {
            event.preventDefault();
            
            mousePosition.x = (event.clientX / window.innerWidth) * 2 - 1;
            mousePosition.y = -(event.clientY / window.innerHeight) * 2 + 1;
            
            raycaster.setFromCamera(mousePosition, camera);
            const intersects = raycaster.intersectObjects(hearts);
            
            if (intersects.length > 0) {
                const heart = intersects[0].object;
                if (!heart.userData.collected) {
                    isDragging = true;
                    draggedHeart = heart;
                    dragStartPosition.copy(heart.position);
                    dragVelocity.set(0, 0, 0);
                    
                    // Show drag instruction
                    document.getElementById('dragInstruction').classList.remove('hidden');
                    setTimeout(() => {
                        document.getElementById('dragInstruction').classList.add('hidden');
                    }, 3000);
                    
                    // Highlight dragged heart
                    heart.material.emissiveIntensity = 2.0;
                    heart.scale.multiplyScalar(1.2);
                }
            }
        }

        // Mouse move event for dragging
        function onMouseMove(event) {
            if (!isDragging || !draggedHeart) return;
            
            const newMousePosition = new THREE.Vector2(
                (event.clientX / window.innerWidth) * 2 - 1,
                -(event.clientY / window.innerHeight) * 2 + 1
            );
            
            // Calculate drag velocity
            dragVelocity.x = (newMousePosition.x - mousePosition.x) * 50;
            dragVelocity.y = (newMousePosition.y - mousePosition.y) * 50;
            
            mousePosition.copy(newMousePosition);
            
            // Update heart position
            raycaster.setFromCamera(mousePosition, camera);
            const plane = new THREE.Plane(new THREE.Vector3(0, 1, 0), 0);
            const intersection = new THREE.Vector3();
            raycaster.ray.intersectPlane(plane, intersection);
            
            if (intersection) {
                draggedHeart.position.copy(intersection);
                draggedHeart.position.y = Math.max(draggedHeart.position.y, 5);
            }
        }

        // Mouse up event for throwing hearts
        function onMouseUp(event) {
            if (isDragging && draggedHeart) {
                isDragging = false;
                
                // Apply throwing velocity
                draggedHeart.userData.dragVelocity.copy(dragVelocity);
                draggedHeart.userData.isDragged = true;
                
                // Reset heart appearance
                draggedHeart.material.emissiveIntensity = 1.0;
                draggedHeart.scale.divideScalar(1.2);
                
                // Create trail effect
                createDragTrail(draggedHeart.position);
                
                draggedHeart = null;
                
                // Create mini fireworks at release point
                createFireworks(1, dragStartPosition);
            }
        }

        // Touch events for mobile
        function onTouchStart(event) {
            event.preventDefault();
            if (event.touches.length === 1) {
                const touch = event.touches[0];
                onMouseDown({ clientX: touch.clientX, clientY: touch.clientY, preventDefault: () => {} });
            }
        }

        function onTouchMove(event) {
            event.preventDefault();
            if (event.touches.length === 1 && isDragging) {
                const touch = event.touches[0];
                onMouseMove({ clientX: touch.clientX, clientY: touch.clientY });
            }
        }

        function onTouchEnd(event) {
            event.preventDefault();
            onMouseUp(event);
        }

        // Create drag trail effect
        function createDragTrail(position) {
            const trailCount = 20;
            const trailGeometry = new THREE.BufferGeometry();
            const trailPositions = new Float32Array(trailCount * 3);
            const trailSizes = new Float32Array(trailCount);
            
            for (let i = 0; i < trailCount; i++) {
                trailPositions[i * 3] = position.x + (Math.random() - 0.5) * 0.5;
                trailPositions[i * 3 + 1] = position.y + (Math.random() - 0.5) * 0.5;
                trailPositions[i * 3 + 2] = position.z + (Math.random() - 0.5) * 0.5;
                
                trailSizes[i] = Math.random() * 0.3 + 0.1;
            }
            
            trailGeometry.setAttribute('position', new THREE.BufferAttribute(trailPositions, 3));
            trailGeometry.setAttribute('size', new THREE.BufferAttribute(trailSizes, 1));
            
            const trailMaterial = new THREE.PointsMaterial({
                size: 0.3,
                color: 0xff5e7d,
                transparent: true,
                opacity: 0.8,
                blending: THREE.AdditiveBlending,
                sizeAttenuation: true
            });
            
            const trail = new THREE.Points(trailGeometry, trailMaterial);
            scene.add(trail);
            
            // Animate trail fading
            let life = 1;
            const animateTrail = () => {
                life -= 0.05;
                
                if (life <= 0) {
                    scene.remove(trail);
                    return;
                }
                
                trailMaterial.opacity = life;
                trailMaterial.size = life * 0.3;
                
                requestAnimationFrame(animateTrail);
            };
            
            animateTrail();
        }

        // Setup UI events
        function setupUIEvents() {
            // Change Scene Button
            document.getElementById('changeScene').addEventListener('click', function() {
                currentScene = (currentScene + 1) % scenes.length;
                changeScene(currentScene);
                createFloatingText("New Universe! üåå", new THREE.Vector3(0, 15, 0), 0xff5e7d);
            });
            
            // Add Hearts Button
            document.getElementById('addHearts').addEventListener('click', function() {
                createFloatingHearts(15);
                createFloatingText("More Love! üíñ", new THREE.Vector3(0, 10, 0), 0xff99ac);
                createFireworks(3);
            });
            
            // Toggle Rose Button
            document.getElementById('toggleRose').addEventListener('click', function() {
                // Placeholder for rose functionality
                createFloatingText("Coming Soon! üåπ", new THREE.Vector3(0, 5, 0), 0xff4081);
            });
            
            // Love Message Button
            document.getElementById('loveMessage').addEventListener('click', function() {
                showSecretMessage();
                createFireworks(2);
            });
            
            // Secret Garden Button
            document.getElementById('secretGarden').addEventListener('click', function() {
                // Placeholder for secret garden
                createFloatingText("Garden Growing! üå∏", new THREE.Vector3(0, 12, 0), 0x9d4edd);
                createFireworks(5);
            });
            
            // Fireworks Button
            document.getElementById('fireworks').addEventListener('click', function() {
                createFireworks(15);
                createFloatingText("Celebration! üéÜ", new THREE.Vector3(0, 20, 0), 0xff9e00);
            });
            
            // Toggle Bloom Button
            document.getElementById('toggleBloom').addEventListener('click', function() {
                isBloomEnabled = !isBloomEnabled;
                bloomPass.enabled = isBloomEnabled;
                createFloatingText(
                    isBloomEnabled ? "Glow On! ‚ú®" : "Glow Off", 
                    new THREE.Vector3(0, 8, 0), 
                    isBloomEnabled ? 0x00b4d8 : 0x888888
                );
            });
            
            // Skybox Mode Button
            document.getElementById('skyboxMode').addEventListener('click', function() {
                // Cycle through skybox modes
                currentScene = (currentScene + 1) % scenes.length;
                changeScene(currentScene);
                createFloatingText("Skybox Changed! üåÖ", new THREE.Vector3(0, 18, 0), 0x38b000);
                createFireworks(8);
            });
            
            // Close Modal Button
            document.getElementById('closeModal').addEventListener('click', hideSecretMessage);
            document.getElementById('modalOverlay').addEventListener('click', hideSecretMessage);
            
            // Escape key to close modal
            document.addEventListener('keydown', function(event) {
                if (event.key === 'Escape') hideSecretMessage();
            });
        }

        // Change scene with enhanced effects
        function changeScene(sceneIndex) {
            currentScene = sceneIndex;
            const sceneConfig = scenes[sceneIndex];
            
            // Update scene background
            scene.background = new THREE.Color(sceneConfig.bgColor);
            
            // Update fog
            scene.fog = new THREE.Fog(sceneConfig.fogColor, 10, 200);
            
            // Update scene name
            document.getElementById('sceneName').textContent = sceneConfig.name;
            
            // Recreate starfield with new colors
            createStarfield(sceneConfig.starCount);
            
            // Update particle colors
            particles.forEach(particle => {
                if (particle.material instanceof THREE.PointsMaterial) {
                    particle.material.color.set(sceneConfig.particleColor);
                }
            });
            
            // Update lighting colors
            scene.traverse(object => {
                if (object.isLight) {
                    if (object.isDirectionalLight || object.isPointLight) {
                        object.color.set(sceneConfig.lightColor);
                    }
                }
            });
            
            // Create transition effect
            createSceneTransition();
        }

        // Create scene transition effect
        function createSceneTransition() {
            const transitionGeometry = new THREE.SphereGeometry(1, 32, 32);
            const transitionMaterial = new THREE.MeshBasicMaterial({
                color: scenes[currentScene].lightColor,
                transparent: true,
                opacity: 1
            });
            
            const transitionSphere = new THREE.Mesh(transitionGeometry, transitionMaterial);
            transitionSphere.scale.set(0.1, 0.1, 0.1);
            transitionSphere.position.copy(camera.position);
            scene.add(transitionSphere);
            
            // Animate transition
            let scale = 0.1;
            const animateTransition = () => {
                scale += 0.1;
                transitionSphere.scale.set(scale, scale, scale);
                transitionMaterial.opacity -= 0.02;
                
                if (transitionMaterial.opacity <= 0) {
                    scene.remove(transitionSphere);
                    return;
                }
                
                requestAnimationFrame(animateTransition);
            };
            
            animateTransition();
        }

        // Start typewriter effect
        function startTypewriterEffect() {
            const typingText = document.getElementById('typingText');
            const message = typewriterMessages[Math.floor(Math.random() * typewriterMessages.length)];
            let charIndex = 0;
            
            function typeNextChar() {
                if (charIndex < message.length) {
                    typingText.textContent = message.substring(0, charIndex + 1);
                    charIndex++;
                    setTimeout(typeNextChar, 50 + Math.random() * 30);
                } else {
                    // After finishing, wait and start new message
                    setTimeout(() => {
                        const newMessage = typewriterMessages[Math.floor(Math.random() * typewriterMessages.length)];
                        typeMessage(newMessage, typingText);
                    }, 3000);
                }
            }
            
            typeNextChar();
        }

        // Type message with typewriter effect
        function typeMessage(message, element) {
            element.textContent = '';
            let charIndex = 0;
            
            function typeNextChar() {
                if (charIndex < message.length) {
                    element.textContent = message.substring(0, charIndex + 1);
                    charIndex++;
                    setTimeout(typeNextChar, 50 + Math.random() * 30);
                }
            }
            
            typeNextChar();
        }

        // Show secret message with typewriter effect
        function showSecretMessage() {
            const messageText = document.getElementById('secretMessageText');
            const modal = document.getElementById('secretModal');
            const overlay = document.getElementById('modalOverlay');
            
            const message = secretMessages[Math.floor(Math.random() * secretMessages.length)];
            messageText.textContent = '';
            
            // Show modal
            overlay.classList.remove('hidden');
            modal.classList.remove('hidden');
            modal.classList.remove('fade-out');
            modal.classList.add('fade-in');
            
            // Type the message
            let charIndex = 0;
            function typeNextChar() {
                if (charIndex < message.length) {
                    messageText.textContent = message.substring(0, charIndex + 1);
                    charIndex++;
                    setTimeout(typeNextChar, 40 + Math.random() * 20);
                }
            }
            
            typeNextChar();
        }

        // Hide secret message
        function hideSecretMessage() {
            const modal = document.getElementById('secretModal');
            const overlay = document.getElementById('modalOverlay');
            
            modal.classList.remove('fade-in');
            modal.classList.add('fade-out');
            
            setTimeout(() => {
                modal.classList.add('hidden');
                overlay.classList.add('hidden');
            }, 500);
        }

        // Update loading progress
        function updateLoadingProgress(percent) {
            const progressBar = document.getElementById('loadingProgress');
            const loadingText = document.querySelector('.loading-text');
            
            progressBar.style.width = `${percent}%`;
            
            const messages = [
                "Loading Eternal Love...",
                "Creating Magic...",
                "Building Dreams...",
                "Generating Stars...",
                "Crafting Hearts...",
                "Almost There..."
            ];
            
            if (percent % 20 === 0) {
                const messageIndex = Math.floor(percent / 20) % messages.length;
                loadingText.textContent = messages[messageIndex];
            }
        }

        // Update particle count
        function updateParticleCount() {
            const totalParticles = hearts.length + (starParticles[0]?.geometry.attributes.position.count || 0);
            document.getElementById('particleCount').textContent = totalParticles.toLocaleString();
        }

        // Update time counter
        function updateTimeCounter() {
            const elapsed = Math.floor((Date.now() - startTime) / 1000);
            const minutes = Math.floor(elapsed / 60);
            const seconds = elapsed % 60;
            
            document.getElementById('timeSpent').textContent = 
                `${minutes}:${seconds.toString().padStart(2, '0')}`;
        }

        // Update love meter
        function updateLoveMeter() {
            const meterValue = Math.min(100, heartCount * 2);
            const meterFill = document.getElementById('meterFill');
            const meterPercent = document.getElementById('meterPercent');
            const loveLevel = document.getElementById('loveLevel');
            
            meterFill.style.width = `${meterValue}%`;
            meterPercent.textContent = `${meterValue}%`;
            loveLevel.textContent = `${meterValue}%`;
        }

        // Window resize handler
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        }

        // Animation loop with enhanced effects
        function animate() {
            requestAnimationFrame(animate);
            
            const time = Date.now() * 0.001;
            
            // Animate hearts with enhanced effects
            hearts.forEach((heart, index) => {
                if (heart.userData && !heart.userData.collected) {
                    // Dragging physics
                    if (heart.userData.isDragged) {
                        heart.position.add(heart.userData.dragVelocity.clone().multiplyScalar(0.016));
                        heart.userData.dragVelocity.multiplyScalar(0.95); // Friction
                        
                        // Gravity
                        heart.userData.dragVelocity.y -= 0.2;
                        
                        // Bounce on ground
                        if (heart.position.y < 0.5) {
                            heart.position.y = 0.5;
                            heart.userData.dragVelocity.y *= -0.8; // Bounce
                            heart.userData.dragVelocity.multiplyScalar(0.9); // Energy loss
                            
                            // Create bounce effect
                            if (Math.abs(heart.userData.dragVelocity.y) > 1) {
                                createBounceEffect(heart.position);
                            }
                        }
                        
                        // Stop dragging if velocity is very small
                        if (heart.userData.dragVelocity.length() < 0.1) {
                            heart.userData.isDragged = false;
                        }
                    } else {
                        // Normal floating animation
                        heart.position.y = heart.userData.originalY + 
                            Math.sin(time * heart.userData.floatSpeed + index) * 
                            heart.userData.floatAmplitude;
                        
                        // Gentle rotation
                        heart.rotation.x += heart.userData.rotationSpeed.x;
                        heart.rotation.y += heart.userData.rotationSpeed.y;
                        heart.rotation.z += heart.userData.rotationSpeed.z;
                    }
                    
                    // Pulsing scale with enhanced effect
                    const pulse = Math.sin(time * heart.userData.pulseSpeed * 2 + index) * 0.15 + 1;
                    heart.scale.setScalar(pulse * heart.userData.originalScale);
                    
                    // Color cycling for some hearts
                    if (index % 3 === 0) {
                        const hue = (heart.userData.hue + time * 0.02) % 1;
                        heart.material.color.setHSL(hue, 0.9, 0.7);
                        heart.material.emissive.setHSL(hue, 0.9, 0.3);
                    }
                    
                    // Emissive pulsing
                    heart.material.emissiveIntensity = 0.8 + Math.sin(time * 2 + index) * 0.4;
                }
            });
            
            // Animate starfield with parallax
            starParticles.forEach((stars, index) => {
                const speed = stars.userData.baseSpeed * (index + 1);
                stars.rotation.y += speed;
                
                // Twinkling effect
                const positions = stars.geometry.attributes.position.array;
                for (let i = 0; i < positions.length; i += 3) {
                    if (Math.random() > 0.99) {
                        positions[i + 1] += (Math.random() - 0.5) * 0.1;
                    }
                }
                stars.geometry.attributes.position.needsUpdate = true;
            });
            
            // Animate particles with enhanced motion
            particles.forEach(particle => {
                if (particle.userData) {
                    particle.rotation.y += particle.userData.speed;
                    
                    // Wave motion for particles
                    const positions = particle.geometry.attributes.position.array;
                    for (let i = 0; i < positions.length; i += 3) {
                        positions[i + 1] += Math.sin(time + i * 0.01) * 0.02;
                    }
                    particle.geometry.attributes.position.needsUpdate = true;
                }
            });
            
            // Update controls
            controls.update();
            
            // Render with post-processing
            if (isBloomEnabled) {
                composer.render();
            } else {
                renderer.render(scene, camera);
            }
        }

        // Create bounce effect
        function createBounceEffect(position) {
            const ringGeometry = new THREE.RingGeometry(0.5, 1, 32);
            const ringMaterial = new THREE.MeshBasicMaterial({
                color: 0xff5e7d,
                transparent: true,
                opacity: 0.8,
                side: THREE.DoubleSide
            });
            
            const ring = new THREE.Mesh(ringGeometry, ringMaterial);
            ring.rotation.x = -Math.PI / 2;
            ring.position.copy(position);
            ring.position.y = 0.1;
            scene.add(ring);
            
            // Animate ring
            let scale = 1;
            const animateRing = () => {
                scale += 0.2;
                ring.scale.set(scale, scale, scale);
                ringMaterial.opacity -= 0.05;
                
                if (ringMaterial.opacity <= 0) {
                    scene.remove(ring);
                    return;
                }
                
                requestAnimationFrame(animateRing);
            };
            
            animateRing();
        }

        // Initialize when page loads
        window.onload = init;
    </script>
</body>
</html>
